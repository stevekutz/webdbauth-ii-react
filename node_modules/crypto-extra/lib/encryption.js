'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.encrypt = encrypt;
exports.decrypt = decrypt;
exports.generateKey = generateKey;

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ALGORITHM = 'aes-256-ctr';
var HMAC_ALGORITHM = 'sha256';

function encrypt(value, key) {
  key = new Buffer(getEncryptionKey(key));

  var iv = new Buffer(_crypto2.default.randomBytes(16));

  var cipher = _crypto2.default.createCipheriv(ALGORITHM, key, iv);
  cipher.setEncoding('hex');
  cipher.write((0, _utils.stringify)(value));
  cipher.end();

  var cipherText = cipher.read();

  var hmac = _crypto2.default.createHmac(HMAC_ALGORITHM, key);
  hmac.update(cipherText);
  hmac.update(iv.toString('hex'));

  return cipherText + '$' + iv.toString('hex') + '$' + hmac.digest('hex');
}

function decrypt(value, key) {
  if (typeof value !== 'string') {
    throw new TypeError('expected a string, got ' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)));
  }

  key = new Buffer(getEncryptionKey(key));

  var cipher = value.split('$');
  var iv = new Buffer(cipher[1], 'hex');

  var hmac = _crypto2.default.createHmac(HMAC_ALGORITHM, key);
  hmac.update(cipher[0]);
  hmac.update(iv.toString('hex'));

  if (!constantTimeCompare(hmac.digest('hex'), cipher[2])) {
    throw new Error('encrypted payload has been tampered with');
  }

  var decipher = _crypto2.default.createDecipheriv(ALGORITHM, key, iv);
  var decryptedText = decipher.update(cipher[0], 'hex', 'utf-8');

  var final = decryptedText + decipher.final('utf8');

  return (0, _utils.parseObject)(final) || final;
}

function generateKey() {
  var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 64;

  length = parseInt(length, 10);

  if (length < 2 || length % 2 !== 0) {
    throw new Error('length must be an even number above 0!');
  }

  return _crypto2.default.randomBytes(length / 2).toString('hex');
}

function constantTimeCompare(val1, val2) {
  var sentinel = void 0;

  if (val1.length !== val2.length) return false;

  for (var i = 0, len = val1.length; i < len; i++) {
    sentinel |= val1.charCodeAt(i) ^ val2.charCodeAt(i);
  }

  return sentinel === 0;
}

function getEncryptionKey(key) {
  key = key || process.env.ENCRYPTION_KEY;
  if (!key) throw new Error('encryption key not found');

  var cryptoKey = _crypto2.default.createHash('sha256').update(key).digest();
  return cryptoKey;
}